At the outset, note that there are two types of files that can be built in
a linked executable: objects and libraries. Objects are included in their
entirety. Library files contain multiple object files; only the objects
that are necessary for extdefs are included in the final exe.

MEMORY USED FOR LINKING:
  TblObjs: Object resolution table: 16 bytes for each object, max 64 objs, 1024 bytes
    uint      Ptr to Object filename.
    byte      Object index within library (for libraries; otherwise 00)
    byte      HasModules bitflag (.....sdc) (code, data, stack)
    uint      Code Segment Size (bytes, 0x0000 = 64kb)
    uint      Data Segment Size
    uint      Code Segment Placement (para-align, loc = placement * 16)
    uint      Data Segment Placement (para-align, loc = placement * 16)
    uint      ptrPubDef (pointer to first entry in pubdef table)
    uint      ptrExtDef (pointer to first entry in extdef table)
  TblExts: ExtDef table (2048 bytes) - We use this table to determine if we have all required PubDefs.
    strpre    DefName
    byte      Object index containing resolved pubdef. (0xff if unresolved)
  TblPubs: PubDef table (2048 bytes) - We use this table to resolve extdefs.
    strpre    DefName
    byte      Object index this pubdef is contained within
    byte      Segment index within Object
    uint      Address offset within Segment

Linking will procede in three stages:
  1.  RESOLVE EXTDEFS, GET NECESSARY OBJECT FILES FROM LIBRARIES:
      foreach (obj in objs) {
        Add obj to tblObjs: name, index (if lib), segment sizes.
        Get segment placement data.
        Get next free byte in tblext and tblpub.
        Build list of pubdefs and extdefs:
          when a extdef is added, if already in the extdef table, skip!
          when a pubdef is added, if already in the pubdef table, error!
      }
      allmatched = matchDefs();
      function matchDefs() {
        foreach (pudbef in tblPubdef) {
          for all matching extdefs, extdef.modidx = pubdef.modidx
        }
        return (all extdefs satisfied ? 1 : 0);
      }
      if (allmatched) {
        // all extdefs satisfied
        procede to next stage.
      }
      else {
        // we need to resolve missing extdefs with libraries:
        while (allmatched == 0) {
          get first unmatched extdef.
          byte matched = 0;
          foreach (lib in libs) {
            if (lib.haspubdef(extdef)) {
              matched = 1;
              add the library object as if it were an obj file.
              allmatched = matchDefs();
              break; // (from foreach lib in libs)
            }
          }
          if (matched == 0) {
            error "could not resolve extdef "x"; abort.
          }
        }
      }
      proceed to stage 2!
      
Stage 2. Determine Object segment offsets in linked exe file.
  We need to figure out where the objects will be placed.
  uint paraData = 0, paraCode = 0;
  foreach (obj in TblObjs) {
    obj.CodeLoc = paraCode;
    obj.DataLoc = paraData;
    paraCode += (obj.CodeSize >> 4);
    if ((obj.CodeSize & 0x000f) != 0) {
      paraCode +=1 ;
    }
    paraData += (obj.DataSize >> 4);
    if ((obj.DataSize & 0x000f) != 0) {
      paraData +=1 ;
    }
  }
  
Stage 3. Write out segments
  Now that we know where all the objects will be placed.
  // add 512 bytes for exe header
  // write out code:
  uint fpos_begin[2], fpos_end[2];
  foreach (obj in TblObjs) {
    foreach (LEDATA/LIDATA in code segment) {
      fpos_begin = btell(fd_exe);
      // write out entire data
      fpos_end = btell(fd_exe);
      if (fixupp) {
        foreach (fixup in fixupp) {
          fd_offset = fpos_begin + fixupp_loc;
          // write appropriate offset.
        }
        fd_offset = fpos_end;
      }
    }
    // pad to next paragraph, if necessary.
  }
  // do the same for data:
  ...
  // what to do with stack...?
  ...
  // done!
  

      
####  Parsing HELLO.OBJ
      First SEGDEF is "CODE", Length = 0x13.
      Second SEGDEF is "DATA", Length = 0xF
0000  Save 512 bytes (16 * 32 bytes) for the header
0200  HELLO.OBJ Write all CODE modules (SegIndex=1)
      A0  LEDATA SegIndex=1 DataOffset=0 Length=2
      A0  LEDATA SegIndex=1 DataOffset=2 Length=11
      Two fixups, will need to be resolved later:
      Rel=Sgmt, Loc=16bit offset, DtOff=4, Frm=Seg 2, Tgt=Seg+2
      Rel=Self, Loc=16bit offset, DtOff=A, Frm=Ext 2, Tgt=Ext+0
      Length = 0x13.Done! 0xD (13) bytes filler to end paragraph.
0220  